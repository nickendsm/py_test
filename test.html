опытка написания программы для моделирования цепочки (13 сентября)
// все в одном файле

#include <iostream>
#include <math.h>
//#include <SFML/Graphics.hpp>
#include <windows.h>
#include <fstream>
#include <thread>
#include <ctime>

const double PI = 3.141592653589793;
struct NODE // структура частицы
{
	NODE() { x = 0; v = 0; u = 0; m = 1; m_2 = 0.5; Const = 0; left = NULL; right = NULL; };

	double x;
	double u;
	double v;
	NODE* left;
	NODE* right;
	double m;
	double m_2; // деленная на два масса,  для ускорения
	double Const;
};

struct Calculation {

	Calculation(double C, size_t N, size_t time, double dt, int hop) : c4(C/4.), N(N), dt(dt), time(time), hop(hop), C(C), howmany(N/4) {
		Nodes = new NODE[N];
		Massive = new double[time];
		p = new double[4]; 
		this->count();
		this->NewData();
	}
	
	void generateWavesRANDOM(int numb, int np1, int np2, double AMPP, int minN, int maxN, int massa, char p) {
		int current = 0;
		int lenMassive = np2 - np1;
		int lenW = 0;
		int Delta = maxN - minN;
		int index0 = 0;
		bool signal = 0;
		int sign = 1;
		if (p == '-') { sign = -1; }
		while (current != numb) {
			lenW = minN + (int)(Delta * (double)rand() / RAND_MAX); // посчитали длину возмущения
			index0 = np1 + (int)((double)rand() / RAND_MAX * (lenMassive - 1 - lenW)); // посчитали его начало
			signal = 0;
			for (int lo = 0; lo < lenW; lo++) {
				if (Nodes[lo + index0].u != 0.) { signal = 1; break; }
			}
			if (signal == 1) { continue; }
			for (int lo = index0; lo < lenW + index0; lo++) {
				Nodes[lo].u += 2*AMPP * (cos(2 * PI / lenW * (lo - index0)) - 1);
				//Nodes[lo].v += sign * 2 * AMPP * pow(C / massa, 1. / 2) * sin(PI / lenW) * sin(2 * PI / lenW * (lo - index0));
			}
			current++;
		}
	}
	void count()
	{
		NODE* temp = 0;
		for (int i = 0; i < N; i++) {
			temp = &Nodes[i];
			temp->x = (double)i * 1000 / (N + 1. / 2);
			// инициализация соседей
			temp->left = &Nodes[(N + i - 1) % N];
			temp->right = &Nodes[(i + 1) % N];
		}
		delete temp;

	}
	void NewData() {
		// задаем во второй части массы другие 
		for (int q = (int)N / 2; q < N; q++) { Nodes[q].m = 2; Nodes[q].m_2 = 1; }
		generateWavesRANDOM(40, 0, 15000, 5, 200, 200, 1, '+');
		generateWavesRANDOM(40, 15000, 30000, 5, 200, 200, 2, '-');
		// задаем Const для частиц
		for (int q = 0; q < N; q++) {
			Nodes[q].Const = C * dt / Nodes[q].m;
		}
	}
	void EnergyCount(int num) {
		for (int k = 0; k < num; k++) {
			p[k] = 0.;
		}
		// складываем энергию по зонам
		for (int w = 0; w < N; w++) {
			ii = w / howmany;
			p[ii] += Nodes[w].m_2 * Nodes[w].v * Nodes[w].v + c4* (pow(Nodes[w].right->u - Nodes[w].u, 2) + pow(Nodes[w].u - Nodes[w].left->u, 2));
		}
	}
	void EnergyCount_th(int num) {
		for (int k = 0; k < num; k++) {
			p[k] = 0.;
		}
		std::thread th1(&Calculation::EnergyThread, this, 0, p);
		std::thread th2(&Calculation::EnergyThread, this, N/4, p+1);
		std::thread th3(&Calculation::EnergyThread, this, N/2, p+2);
		std::thread th4(&Calculation::EnergyThread, this, 0.75*N, p+3);
		th1.join();
		th2.join();
		th3.join();
		th4.join();
	}
	double c4;
	size_t howmany;
	size_t ii;
	size_t kk = 0;
	double C;
	size_t N; 
	size_t time;
	double dt; 
	double* Massive; // массив с разницей энергий, который будем выводить в файл
public:
	void phys() {
		// сначала скорости
		for (int i = 0; i < N; i++) {
			Nodes[i].v += (Nodes[i].left->u - 2 * Nodes[i].u + Nodes[i].right->u) * Nodes[i].Const;
		}
		// теперь перемещения 
		for (int i = 0; i < N; i++) {
			Nodes[i].u += Nodes[i].v * dt;
		}
	}
	void SaveValues(const char* filename) { 
		std::ofstream os(filename);
		for (int u = 0; u < N; u++) {
			os << Nodes[u].u << "," << Nodes[u].v << ';';
		}
		os << "time: " << this->time;
		os.close();
	}
	void WRITEFILE(const char* filename) {
		std::ofstream os(filename);
		for (int u = 0; u < kk; u++)
		{
			os << Massive[u] << " ";
		}
		os.close();
	}
	void control() {
		phys();
		EnergyCount(4);
		Massive[kk] = (p[0]+p[1])-(p[2]+p[3]);
		kk++;
	}
	NODE* Nodes; // указатель на массив из NODE
	double* p; // указатель на массив с энергиями, расчитывается в void EnergyCount
	int hop;
}
;

void thread_calc(double C, size_t N,size_t TIME, double dt, int hop) {
	// запускаем расчет 
	
	Calculation calc = Calculation(C, N, TIME, dt, hop);
	for (int j = 0; j < TIME; j++)
	{
		calc.control();
	}
}
int main() {
	double T = 2 * PI / 10;
	long int TIME = 2000;
	int N = 30000;
	long int hop = 1;
	int scale = 10;
	
	const int width = 1000;
	const int height = 500;
	Calculation calc = Calculation(100, N, TIME, 0.05 * T, hop);
	for (int j = 0; j < TIME; j++)
	{
		calc.control();
	}
	return 0;
}